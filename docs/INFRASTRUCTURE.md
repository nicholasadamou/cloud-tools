# üèóÔ∏è Cloud Tools Infrastructure

> **Complete Terraform infrastructure for the Cloud Tools file processing platform**

### üåü Key Features

- ‚úÖ **Complete AWS Infrastructure**: S3, DynamoDB, SQS, Lambda, API Gateway, CloudWatch
- ‚úÖ **Multi-Environment Support**: Separate configurations for dev, staging, and production
- ‚úÖ **Security Best Practices**: IAM roles with least privilege, encryption, WAF
- ‚úÖ **Cost Optimization**: Intelligent tiering, pay-per-request billing, automated cleanup
- ‚úÖ **Monitoring & Alerting**: CloudWatch dashboards, alarms, budget notifications
- ‚úÖ **Infrastructure as Code**: Version-controlled, repeatable deployments
- ‚úÖ **Automated Deployment**: Scripts and documentation for easy setup

## üìÅ New Infrastructure Structure

```
cloud-tools/
‚îú‚îÄ‚îÄ client/                     # üñ•Ô∏è Next.js web application (@cloud-tools/client)
‚îÇ   ‚îú‚îÄ‚îÄ app/                   # Next.js app directory
‚îÇ   ‚îú‚îÄ‚îÄ components/            # React components
‚îÇ   ‚îî‚îÄ‚îÄ lib/                   # Client-specific utilities
‚îú‚îÄ‚îÄ infrastructure/             # üèóÔ∏è Terraform and Lambda functions
‚îÇ   ‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lambda/src/         # üì¶ Lambda workspace (@cloud-tools/lambda)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ handlers/      # Lambda function handlers
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ adapters/      # AWS service adapters
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ tsconfig.json  # Lambda TypeScript config
‚îÇ   ‚îî‚îÄ‚îÄ environments/          # Environment-specific configs
‚îÇ       ‚îú‚îÄ‚îÄ dev/               # Development environment
‚îÇ       ‚îú‚îÄ‚îÄ staging/           # Staging environment
‚îÇ       ‚îî‚îÄ‚îÄ production/        # Production environment
‚îú‚îÄ‚îÄ terraform/                  # üÜï Complete Terraform infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ README.md              # Detailed infrastructure docs
‚îÇ   ‚îú‚îÄ‚îÄ main.tf                # Main configuration
‚îÇ   ‚îú‚îÄ‚îÄ variables.tf           # Global variables
‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf             # Infrastructure outputs
‚îÇ   ‚îú‚îÄ‚îÄ modules/               # Reusable Terraform modules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ s3/                # File storage
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dynamodb/          # Job tracking
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sqs/               # Message queues
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lambda/            # Processing functions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-gateway/       # REST API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cloudwatch/        # Monitoring
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ iam/               # Security & permissions
‚îÇ   ‚îî‚îÄ‚îÄ scripts/               # Deployment utilities
‚îÇ       ‚îî‚îÄ‚îÄ deploy.sh          # Automated deployment
‚îú‚îÄ‚îÄ lib/                       # üìö Shared libraries and utilities
‚îÇ   ‚îú‚îÄ‚îÄ aws-config.ts         # AWS configuration
‚îÇ   ‚îî‚îÄ‚îÄ worker.ts             # File processing logic
‚îú‚îÄ‚îÄ docs/                      # üìñ Documentation
‚îú‚îÄ‚îÄ scripts/                   # üîß Development scripts
‚îú‚îÄ‚îÄ pnpm-workspace.yaml        # PNPM workspace configuration
‚îî‚îÄ‚îÄ ... (config files)
```

## üöÄ Quick Infrastructure Deployment

### Prerequisites

1. **AWS CLI** configured with admin permissions
2. **Terraform** >= 1.0 installed
3. **Basic AWS knowledge** (S3, Lambda, etc.)

### 1Ô∏è‚É£ Setup Backend (One-time)

```bash
# Create S3 bucket for Terraform state
aws s3 mb s3://cloud-tools-terraform-state-dev

# Create DynamoDB table for state locking
aws dynamodb create-table \
  --table-name cloud-tools-terraform-locks-dev \
  --attribute-definitions AttributeName=LockID,AttributeType=S \
  --key-schema AttributeName=LockID,KeyType=HASH \
  --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1
```

### 2Ô∏è‚É£ Deploy Infrastructure

```bash
# Navigate to terraform directory
cd terraform

# Deploy development environment
./scripts/deploy.sh -e dev -a plan    # Review changes
./scripts/deploy.sh -e dev -a apply   # Deploy infrastructure

# Deploy production environment
./scripts/deploy.sh -e production -a plan
./scripts/deploy.sh -e production -a apply
```

### 3Ô∏è‚É£ Get Deployment Info

```bash
# Get API Gateway URL and other outputs
cd terraform/environments/dev
terraform output

# Example output:
# api_gateway_url = "https://abc123.execute-api.us-east-1.amazonaws.com/dev"
# s3_bucket_name = "cloud-tools-dev-a1b2c3d4"
# dynamodb_table_name = "CloudToolsJobs-dev-a1b2c3d4"
```

## üèóÔ∏è Infrastructure Architecture

The Terraform configuration creates a complete serverless architecture:

```mermaid
graph TB
    subgraph "Frontend (Vercel)"
        UI[Next.js Application<br/>cloud-tools.vercel.app]
    end

    subgraph "AWS Infrastructure (Terraform)"
        subgraph "API Layer"
            APIG[API Gateway<br/>REST Endpoints]
        end

        subgraph "Compute Layer"
            LC[Convert Lambda<br/>File Conversion]
            LCP[Compress Lambda<br/>File Compression]
            LP[Process Lambda<br/>Background Worker]
        end

        subgraph "Storage Layer"
            S3[S3 Bucket<br/>File Storage]
            DDB[DynamoDB<br/>Job Tracking]
        end

        subgraph "Message Layer"
            SQS[SQS Queue<br/>Job Processing]
            DLQ[Dead Letter Queue<br/>Failed Jobs]
        end

        subgraph "Monitoring Layer"
            CW[CloudWatch<br/>Logs & Metrics]
            SNS[SNS Topics<br/>Alerts]
        end
    end

    UI --> APIG
    APIG --> LC
    APIG --> LCP
    LC --> SQS
    LCP --> SQS
    SQS --> LP

    LC --> S3
    LP --> S3
    LC --> DDB
    LP --> DDB

    CW --> SNS
```

## üåç Environment Configuration

### Development Environment

- **Purpose**: Local development and testing
- **Cost**: ~$5-10/month
- **Features**: Basic monitoring, localhost CORS, reduced retention
- **Security**: Relaxed (no WAF, simplified policies)

### Production Environment

- **Purpose**: Live application workloads
- **Cost**: ~$20-100/month (usage-based)
- **Features**: Full monitoring, alerting, backups, enhanced security
- **Security**: Hardened (WAF enabled, strict CORS, comprehensive logging)

## üí° Integration with Existing Project

The infrastructure is designed to work seamlessly with your existing Next.js application:

### 1. Update Environment Variables

After deployment, update your `.env.local`:

```bash
# Get infrastructure outputs
cd terraform/environments/dev
terraform output -json > ../../../infrastructure-outputs.json

# Update your .env.local with the outputs
AWS_REGION=us-east-1
S3_BUCKET_NAME=cloud-tools-dev-a1b2c3d4
DDB_TABLE_NAME=CloudToolsJobs-dev-a1b2c3d4
SQS_QUEUE_URL=https://sqs.us-east-1.amazonaws.com/123456789012/cloud-tools-jobs-queue-dev-a1b2c3d4
API_GATEWAY_URL=https://abc123.execute-api.us-east-1.amazonaws.com/dev
```

### 2. Lambda Functions - Full TypeScript Integration

The Terraform configuration includes **production-ready Lambda functions** with complete TypeScript integration using your existing worker logic:

**‚úÖ What's Included:**

- **Real Processing Logic**: Direct integration with your `lib/worker.ts` processors
- **Automated Build**: TypeScript compilation with esbuild bundling
- **AWS SDK v3**: Optimized Lambda implementations for S3, DynamoDB, SQS
- **Error Handling**: Production-ready error handling and logging
- **Auto-deployment**: Functions are built and deployed automatically by Terraform

**üîß Build Process:**

```bash
# Lambda functions are automatically built during terraform apply
# The build process:
# 1. Compiles TypeScript handlers with esbuild
# 2. Bundles with your worker processors (Sharp, FFmpeg, PDF-lib)
# 3. Creates optimized deployment packages
# 4. Installs production dependencies
# 5. Creates ZIP packages for Lambda deployment

# Manual build (if needed):
cd terraform/modules/lambda
./build.sh
```

**üìÅ Lambda Function Architecture:**

- **`convert.ts`**: API Gateway handler for synchronous file conversion
  - Integrates with `SharpImageConverter`, `FFmpegVideoConverter`, `PDFCompressor`
  - Handles CORS, error responses, job status updates
  - Returns immediate results for API Gateway integration

- **`compress.ts`**: API Gateway handler for file compression
  - Uses your existing compression algorithms and settings
  - Supports all formats from your worker implementation
  - Provides compression ratio and file size reports

- **`process.ts`**: SQS message handler for background processing
  - Processes long-running jobs asynchronously
  - Handles retry logic and dead letter queue integration
  - Uses your complete processor pipeline

- **`aws-lambda-adapter.ts`**: AWS service implementations optimized for Lambda
  - `LambdaS3FileStorage`: S3 operations with your existing interface
  - `LambdaSqsMessageQueue`: SQS polling and message management
  - `LambdaJobStatusUpdater`: DynamoDB job tracking with your schema
  - `LambdaLogger`: CloudWatch-optimized structured logging

**üöÄ Key Integration Benefits:**

- **Zero Code Duplication**: Uses your existing worker processors directly
- **Production-Ready**: Error handling, logging, monitoring built-in
- **Performance Optimized**: Bundled with esbuild, tree-shaked dependencies
- **AWS-Native**: Leverages Lambda environment optimizations
- **Type-Safe**: Full TypeScript support with your existing types

## üèóÔ∏è Monorepo Integration

### Lambda Workspace (`@cloud-tools/lambda`)

The Lambda functions are now part of the monorepo workspace system:

```bash
# Build Lambda functions using workspace commands
pnpm run lambda:build       # Build TypeScript Lambda functions
pnpm run lambda:type-check   # Type check Lambda code
pnpm run lambda:clean        # Clean Lambda dist directory

# Or work directly in the Lambda workspace
pnpm --filter @cloud-tools/lambda build
pnpm --filter @cloud-tools/lambda type-check
```

### Shared Library Integration

The Lambda functions use the shared `lib/` directory with path aliases:

```typescript
// Lambda handlers can import shared code cleanly
import { QueueWorker, SharpImageConverter } from "@/lib/worker";
import { JobStatus, AWS_RESOURCES } from "@/lib/aws-config";

// AWS adapters provide Lambda-optimized implementations
import { createLambdaWorkerDependencies } from "@/adapters/aws-lambda-adapter";
```

### Build Integration

The Terraform infrastructure automatically builds the Lambda workspace:

1. **TypeScript Compilation**: Uses the Lambda workspace's `tsconfig.json`
2. **Dependency Resolution**: Resolves shared dependencies from `lib/`
3. **Bundle Creation**: Creates optimized Lambda deployment packages
4. **Deployment**: Deploys to AWS with proper IAM roles and permissions

### 3. Update Frontend Configuration

Your Next.js app can now use the deployed infrastructure:

```typescript
// lib/aws-config.ts - Update with infrastructure outputs
const awsConfig = {
  region: process.env.AWS_REGION,
  endpoint:
    process.env.NODE_ENV === "development"
      ? process.env.AWS_ENDPOINT_URL
      : undefined, // Use real AWS in production
  // ... rest of config
};

// For production, remove LocalStack configuration
// and use the actual AWS resources created by Terraform
```

## üìä Cost Breakdown

### Development Environment (~$5-10/month)

- **Lambda**: $1-3 (based on usage)
- **API Gateway**: $1-2 (per million requests)
- **DynamoDB**: $1-2 (on-demand billing)
- **S3**: $1-2 (storage + requests)
- **CloudWatch**: $1-2 (logs + metrics)
- **Other**: $1-2 (SQS, SNS, etc.)

### Production Environment (~$20-100/month)

- **Lambda**: $5-20 (higher usage)
- **API Gateway**: $3-15 (more requests)
- **DynamoDB**: $5-20 (more data + backups)
- **S3**: $3-10 (more files + intelligent tiering)
- **CloudWatch**: $3-10 (enhanced monitoring)
- **Other**: $2-5 (WAF, enhanced features)

_Costs are estimates based on moderate usage. Actual costs depend on your specific usage patterns._

## üîí Security Features

### Implemented Security Measures

- ‚úÖ **IAM Roles**: Least privilege access for all services
- ‚úÖ **Encryption**: All data encrypted at rest and in transit
- ‚úÖ **Network Security**: Private subnets, security groups (production)
- ‚úÖ **API Security**: WAF protection, rate limiting (production)
- ‚úÖ **Access Controls**: S3 public access blocked, CORS configured
- ‚úÖ **Monitoring**: CloudTrail, GuardDuty integration ready

### Security Best Practices

- üîê **Secrets Management**: Use AWS Secrets Manager for sensitive data
- üîç **Audit Logging**: All API calls logged via CloudTrail
- üö´ **Principle of Least Privilege**: Each service has minimal required permissions
- üîÑ **Regular Updates**: Keep Terraform providers and modules updated

## üìö Documentation

- **üìñ [Complete Infrastructure Guide](../terraform/README.md)**: Detailed Terraform documentation
- **üöÄ [Quick Setup](QUICK_SETUP.md)**: Your existing quick setup guide
- **‚öôÔ∏è [Worker Setup](WORKER_SETUP.md)**: Your existing worker documentation
- **üé≠ [ACT Usage](ACT_USAGE.md)**: Your existing GitHub Actions local testing

## ü§ù Contributing to Infrastructure

1. **Follow IaC best practices**: Document changes, test in dev first
2. **Use consistent naming**: Follow the established resource naming pattern
3. **Security first**: Always consider security implications of changes
4. **Cost awareness**: Consider cost impact of new resources
5. **Test thoroughly**: Validate in dev before promoting to production

## üÜô Migration from LocalStack

Your existing LocalStack development setup remains unchanged! The Terraform infrastructure provides:

- **Development**: Use LocalStack for local development (as you do now)
- **Testing**: Deploy to AWS dev environment for integration testing
- **Production**: Deploy to AWS production environment for live traffic

## üéâ What's Next?

With your infrastructure now codified and deployable:

1. **üöÄ Deploy to AWS**: Get your app running in the cloud
2. **üîÑ Set up CI/CD**: Automate deployments with GitHub Actions
3. **üìä Monitor Performance**: Use the CloudWatch dashboards
4. **üí∞ Optimize Costs**: Review cost reports and optimize as needed
5. **üîí Enhance Security**: Add additional security layers as needed

---

**üéØ Ready to deploy your infrastructure?** Head over to the [terraform/README.md](../terraform/README.md) for complete setup instructions!
